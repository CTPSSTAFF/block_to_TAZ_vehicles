---
title: "Merging Blocks and TAZs"
author: "Author Goes Here"
date: "`r Sys.Date()`"
format: 
  html: 
    self-contained: true
editor: visual
---

## Goal

We want a way to allocate census information into TAZs. TAZs are made up of census blocks, but sometimes split the blocks. We want to create a table that gives us a way to allocate census factors into TAZs.

### Set up Packages

```{r}
#| message: false
library(tidyverse)
library(tidycensus)
library(tigris)
library(mapview)
library(sf)
library(units)
```

## General Goal

The TDM outputs results at a TAZ level. However, for equity analyses, we need to allocated census demographics to those TAZs--the model does not output results based on minority status, income status, or any other status that might be interesting for an equity analysis.

Census geometry does NOT fit neatly into TAZ geometry. We would like to allocate pieces of census demographics to surrounding TAZs to create demographics of the TAZs. We need to create a table that we can use to allocate portions of census geometry into TAZs.

**Problems:**

-   TAZs are mostly made up of blocks, but they're not exactly made up of blocks.
-   There are small tweaks to the TAZ geometry throughout the model region that mean lines do not overlap exactly.
-   Census blocks are NOT necessarily the best starting point because the differential privacy features of the 2020 census have rendered them unreliable.
-   TAZs may be smaller than a census geometry.

**Constraints:**

-   TAZ geometry may change over time. The process should be repeatable for arbitrary TAZ geometry (this essentially means for ANY geometry).

-   We want the process to be maintainable over multiple ACS iterations.

**Other Goals**

-   Create multiple methods to compare the sensitivity to methodology.

**Potential Solutions**

When joining 2010 census blocks to TAZs, Paul Reim performed a series of intersections to identify where blocks were split. Where a TAZ split a block, he counted rooftops and used StreetView to estimate how many rooftops were in each TAZ. It is not desirable to maintain such a process--the reproducibility is limited and its highly manual. We can replicate the methodology using the rooftops layer

## Load shapes

```{r}
#| results: hide
 
#Load TAZ shapes
TAZ <- sf::read_sf("J:/Shared drives/Data_Requests/TAZ_Shapefiles/R_Script/out/geopackage/TAZ19.gpkg") %>% 
  st_transform(26986) %>% 
  filter(STATE == "MA") # Filtering to only in MA

TAZ$TAZ_area <- st_area(TAZ)
  #filter(ID == 4398) # Filtering for one example

# Load census block groups (other geography) tigris::block_groups()
cbtrue <- tigris::block_groups(state = "MA", cb = TRUE, year = 2020)%>% 
  st_transform(26986)
cbfalse <- tigris::block_groups(state = "MA", cb = FALSE, year = 2020) %>% 
  st_transform(26986)

#mapview(cbfalse) + mapview(TAZ, col.regions = "red") #+ mapview(cbtrue, col.regions = "yellow")

# cbfalse looks like it more closely follows the TAZ geometry


# massgis census: https://www.mass.gov/info-details/massgis-data-2020-us-census

#massgis rooftops: https://www.mass.gov/info-details/massgis-data-building-structures-2-d
# rooftops <- st_read("data/base/STRUCTURES_POLY.shp")
# 
# saveRDS(rooftops, "data/processed/rooftops.rds")


# Load Population Census Data
# downloaded from: https://data.census.gov/table?t=Race+and+Ethnicity&g=0400000US25$1500000&tid=DECENNIALPL2020.P1
minority <- read_csv("data/base/DECENNIALPL2020.P1-Data.csv")





# problems that might come up. TAZ to census boundaries might be different (like microscopically different).

# find out which "block" shapes are used to create TAZs
# tiger/cartographic/state via massGIS.

# SPA give the TAZ geometry.
```

## Only Looking at Plymouth County

```{r}
TAZ_ply <- TAZ %>% 
  filter(COUNTY == "Plymouth MA")

blk_group_ply <- cbfalse %>% 
  filter(COUNTYFP == "023")
```

## Taking out the Water Area

```{r}

TAZ_land <- tigris::erase_water(TAZ_ply, area_threshold = 0.5, year = 2020)

blk_groups_land <- tigris::erase_water(blk_group_ply, area_threshold = 0.5, year = 2020)

mapview(blk_groups_land) + mapview(TAZ_land, col.regions = "red")


#tigris::area_water()
# maybe break down at the county level
```

## Perform Intersections

### Intersections

```{r}
intersections <- st_intersection(TAZ_land, blk_groups_land) %>% 
  st_collection_extract("POLYGON") %>% 
  rowid_to_column("Intersection_ID") # unique ID for each intersection geometry
intersections$intersect_area <- st_area(intersections)

mapview(TAZ_land, col.regions = "red") + mapview(blk_groups_land) + mapview(intersections, zcol = "Intersection_ID")


# Trying it out with a subset
# ss_intersection <- intersections %>% 
#   filter(ID == 4398) %>% 
#   st_as_sf() 
# ss_intersection$area <- st_area(ss_intersection)
# ss_intersection$pct_intersect <- ss_intersection$area / max(ss_intersection$area)
# 
# ss_intersection_final <- ss_intersection %>% 
#   filter(as.vector(pct_intersect) > 0.01)
# 
# plot(st_geometry(ss_intersection_final))


# Only keeping intersection areas for a TAZ that is at least 1% of the TAZ area 
# (could also make it 1% of the largest intersection area)
# intersections_clean <- intersections %>% 
#   group_by(ID) %>% 
#   mutate(pct_intersect = intersect_area / TAZ_area ) %>% 
#   filter(as.vector(pct_intersect) > 0.01) %>% 
#   ungroup() 

```

```{r}
example <- intersections %>% 
  filter(ID == 1759) 
mapview(TAZ_land, col.regions = "red") + mapview(blk_groups_land) + mapview(example, zcol = "Intersection_ID")
```

### Different Method for Doing Intersections

```{r}
intersections_2 <- st_join(TAZ, cbfalse, 
                           join = st_intersects, 
                           largest = TRUE)
mapview(intersections_2) + mapview(TAZ)

# This method is not correct because it only pairs one TAZ with one block group, and also does not result in the geometry of the intersection, only the TAZ



```

## Look at Rooftop Share

#### Determine the Number of Rooftops in Each Intersection Area

```{r}
rooftops <- read_rds("data/processed/rooftops.rds")
plot(st_geometry(head(rooftops,1)))

#intersecting the rooftops with the census block groups
#roofs_in_bg <- st_intersection(blk_groups_land, rooftops)

# finding the number of rooftops in each census block group
# num_rooftops <- roofs_in_bg %>% 
#   group_by(GEOID) %>% 
#   mutate(num_roof = n()) %>%  
#   distinct(GEOID, num_roof)
# saveRDS(roofs_in_bg, "data/processed/rooftops_in_bg.rds")
# saveRDS(num_rooftops, "data/processed/num_rooftops.rds")

rooftops <- rooftops %>% 
  select(c(STRUCT_ID))

intersections <- intersections %>% 
  select(c(Intersection_ID, ID, GEOID, intersect_area))

# Joining the intersection areas with the rooftops that reside inside of them
# This took a very long time
roofs_in_intersect <- st_join(rooftops, intersections,
                              left= FALSE, largest = TRUE)

# NOTE: STRUCT_ID 250858_862528 still appears in two intersections areas, it is the only one.  

# keeping the intersection area with the largest part of the rooftop
# roofs_in_intersect_clean <- roofs_in_intersect %>%
  # group_by(STRUCT_ID) %>% 
  # top_n(1)  

num_rooftops <- roofs_in_intersect %>% 
  st_drop_geometry() %>% 
  group_by(Intersection_ID) %>% 
  mutate(num_roof = n()) %>% 
  distinct(Intersection_ID, ID, GEOID, intersect_area, num_roof)

saveRDS(roofs_in_intersect, "data/processed/rooftops_in_intersect.rds")
saveRDS(num_rooftops, "data/processed/num_rooftops_intersect.rds")
```

#### Determine the percentage of population that belongs to each intersection in the TAZ based on the number of rooftops

```{r}

# Get population for block groups
census_pop <- minority %>% 
  select(c(GEO_ID, P1_001N)) %>% 
  rename(GEOID = GEO_ID, population_BG = P1_001N)
census_pop$GEOID <-str_remove_all(census_pop$GEOID, "1500000US")


pop_percent <- num_rooftops %>% 
  group_by(GEOID) %>%
  # per BG: get percentage of rooftops that are in each intersecting TAZ
  mutate(population_pct = num_roof / sum(num_roof)) %>% 
  ungroup() %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = population_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_roof = sum(population_intersection)) %>% 
  ungroup()

TAZ_pop_rooftops <- pop_percent %>% 
  distinct(ID, population_TAZ_roof)

TAZ_plot <- TAZ_land %>% 
  left_join(TAZ_pop_rooftops)
mapview(TAZ_plot, zcol = "population_TAZ")
```

## Look at Area Share

#### Land Area only

```{r}
# First step is to separate out water area in each of the intersections to determine what percentage of block group area should be applied to the population for that block group

TAZ_land$TAZ_land_area <- st_area(TAZ_land)
blk_groups_land$BG_area <- st_area(blk_groups_land) # could also just take ALAND

# Then, for each TAZ, the population of the intersected block groups should be added up.

intersections_AS <- st_intersection(TAZ_land, blk_groups_land) %>% 
  st_collection_extract("POLYGON") %>% 
  rowid_to_column("Intersection_ID") # unique ID for each intersection geometry
intersections_AS$intersect_area <- st_area(intersections_AS)

land_areas <- intersections_AS %>% 
  select(c(Intersection_ID, ID, TAZ_land_area, GEOID, BG_area, intersect_area)) %>%
  group_by(GEOID) %>% 
  # per BG: get percentage of land area that is in each intersecting TAZ
  mutate(BG_land_pct = intersect_area / BG_area) %>% 
  ungroup() %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = BG_land_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_LA = drop_units(sum(population_intersection))) %>% 
  ungroup()

TAZ_pop_LandArea <- land_areas %>% 
  distinct(ID, population_TAZ_LA)



# Pct Difference between the two
diff <- TAZ_pop_rooftops %>% 
  left_join(TAZ_pop_LandArea) %>% 
  mutate(pct_diff = population_TAZ_roof / population_TAZ_LA )
hist(diff$pct_diff, 40)

```

#### Total Area

```{r}

blk_group_ply$BG_area <- st_area(blk_group_ply) # could also just take ALAND

# Then, for each TAZ, the population of the intersected block groups should be added up.

intersections_tot <- st_intersection(TAZ_ply, blk_group_ply) %>% 
  st_collection_extract("POLYGON") %>% 
  rowid_to_column("Intersection_ID") # unique ID for each intersection geometry
intersections_tot$intersect_area <- st_area(intersections_tot)

tot_areas <- intersections_tot %>% 
  select(c(Intersection_ID, ID, TAZ_area, GEOID, BG_area, intersect_area)) %>%
  group_by(GEOID) %>% 
  # per BG: get percentage of land area that is in each intersecting TAZ
  mutate(BG_tot_pct = intersect_area / BG_area) %>% 
  ungroup() %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = BG_tot_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_totA = drop_units(sum(population_intersection))) %>% 
  ungroup()

TAZ_pop_TotArea <- tot_areas %>% 
  distinct(ID, population_TAZ_totA)



# Pct Difference between the two
diff <- TAZ_pop_TotArea %>% 
  left_join(TAZ_pop_LandArea) %>% 
  mutate(pct_diff = population_TAZ_totA / population_TAZ_LA )
hist(diff$pct_diff, 40)

```

## Testing

### Test minority share

```{r}

```

Thoughts:

-   some TAZs are smaller than blockgroups. Do we need to adjust the method of analysis for those cases? It could be the same. Since we are looking for the percentage of the block group that is within the TAZ, then it wouldn't matter if it is smaller or larger. In this case, it just wouldn't also be sharing area with other block groups.

    ![](images/image-779890944.png)

-   There are 17,000 intersection areas, meaning that the boundaries probably don't add up. Brought it down to 8843 by taking out the smallest intersection areas

-   Anything with the rooftops takes a very long time

-   the number of census block groups goes from 5116 to 5110, meaning there are 6 block groups with no rooftops. Also does not take into account if there are rooftops that intersect multiple blockgroups. For some reason, there are less unique IDs in roofs_in_cb than there are in rooftops, but the sum in num_rooftops is the same as the number of entries in roofs_in_cb
