---
title: "Merging Blocks and TAZs"
author: "Author Goes Here"
date: "`r Sys.Date()`"
format: 
  html: 
    self-contained: true
editor: visual
---

**TODO**:

-   Rename `cbfalse` to be more descriptive of what it is.
-   Remove "Different Method for Intersections" since we didn't use it.
-   Remove duplicate rooftops: \`rooftops \|\> st_drop_geometry() \|\> group_by(STRUCT_ID) \|\> tally() \|\> filter(n\>1) \|\> View()\` Example: STRUCT_ID == "250858_862528". There are also STRUCT_IDs with values of "NA" that we should explore. Are they duplicate? Are they just unlabeled?
-   Remove vestigial commented out code.
-   Export only the allocation table: GEOID, TAZ, share_of_geoid_to_TAZ_method1 (then repeat for methods 2 and 3). Once you're happy you can join them together to compare. In the end, we'll keep one method. We also want to be able to attach the dasymetric method later too.

Notes: You don't have to wrap select() arguments in c(). Using tidycensus gives you a cleaner table to start with rather than grabbing a flat file from the census and storing in in a folder. The end result should be the same.

## General Goal

The TDM outputs results at a TAZ level. However, for equity analyses, we need to allocated census demographics to those TAZs--the model does not output results based on minority status, income status, or any other status that might be interesting for an equity analysis.

Census geometry does NOT fit neatly into TAZ geometry. We would like to allocate pieces of census demographics to surrounding TAZs to create demographics of the TAZs. We need to create a table that we can use to allocate portions of census geometry into TAZs.

**Problems:**

-   TAZs are mostly made up of blocks, but they're not exactly made up of blocks.
-   There are small tweaks to the TAZ geometry throughout the model region that mean lines do not overlap exactly.
-   Census blocks are NOT necessarily the best starting point because the differential privacy features of the 2020 census have rendered them unreliable.
-   TAZs may be smaller than a census geometry.

**Constraints:**

-   TAZ geometry may change over time. The process should be repeatable for arbitrary TAZ geometry (this essentially means for ANY geometry).

-   We want the process to be maintainable over multiple ACS iterations.

**Other Goals**

-   Create multiple methods to compare the sensitivity to methodology.

**Potential Solutions**

When joining 2010 census blocks to TAZs, Paul Reim performed a series of intersections to identify where blocks were split. Where a TAZ split a block, he counted rooftops and used StreetView to estimate how many rooftops were in each TAZ. It is not desirable to maintain such a process--the reproducibility is limited and its highly manual. We can replicate the methodology using the rooftops layer. There are other solutions available as well:

1.  Rooftops
    i.  Allocate based on where the largest piece is
    ii. Where the centroid of the roof is
    iii. Allocate proportionally based on the rooftop area.
2.  Land Area
3.  Total Area
4.  Dasymetric Mapping

### Useful references

-   massgis census: <https://www.mass.gov/info-details/massgis-data-2020-us-census>

-   MassDOT rooftops: <https://www.mass.gov/info-details/massgis-data-building-structures-2-d>

## Set up Packages

```{r}
#| message: false
library(tidyverse)
library(tidycensus)
library(tigris)
library(mapview)
library(sf)
library(units)
```

## Load Census, TAZ, and Rooftop Shapes

```{r}
#| results: hide
 
#Load TAZ shapes
TAZ <- sf::read_sf("J:/Shared drives/Data_Requests/TAZ_Shapefiles/R_Script/out/geopackage/TAZ19.gpkg") %>% 
  st_transform(26986) %>% 
  filter(STATE == "MA") # Filtering to only in MA

TAZ$TAZ_area <- st_area(TAZ)
  #filter(ID == 4398) # Filtering for one example

# Load census block groups (other geography) 
# cbtrue <- tigris::block_groups(state = "MA", 
#                                cb = TRUE, 
#                                year = 2020)%>%
#   st_transform(26986)

cbfalse <- tigris::block_groups(state = "MA", 
                                cb = FALSE, 
                                year = 2020) %>% 
  st_transform(26986)

#mapview(cbfalse) + mapview(TAZ, col.regions = "red") #+ mapview(cbtrue, col.regions = "yellow")

# The CB false (the more detailed) geometry looked like it matched up better, so we move forward with that path.


#massgis rooftops: https://www.mass.gov/info-details/massgis-data-building-structures-2-d
# Download the file into "./data/base/" and then read it in here. Save it as a .rds for easy loading. Optionally, we could 
# rooftops <- st_read("data/base/STRUCTURES_POLY.shp")
# 
# saveRDS(rooftops, "data/processed/rooftops.rds")


# Load Population Census Data
# downloaded from: https://data.census.gov/table?t=Race+and+Ethnicity&g=0400000US25$1500000&tid=DECENNIALPL2020.P1
minority <- read_csv("data/base/DECENNIALPL2020.P1-Data.csv")

# P2_005N: Non-Hispanic/Latino, White-alone.
# P1_001N: Total Population.
minority_tidy <- tidycensus::get_decennial(
  geography = "block group",
  state = "MA",
  variable = "P2_005N",
  summary_var = "P1_001N",
  year = 2020)

```

### Only Looking at Plymouth County

We start by filtering out for just Plymouth County to keep the problem small while we work through the process.

```{r}
# ply = Plymouth.
TAZ_ply <- TAZ %>% 
  filter(COUNTY == "Plymouth MA")

# 023 = Plymouth
# See: tidycensus::fips_codes |> filter(state == "MA", county_code == "023")
blk_group_ply <- cbfalse %>% 
  filter(COUNTYFP == "023")
```

## Taking out the Water Area

In this section we remove the water from the geography to focus only on "land area".

```{r}

TAZ_land <- tigris::erase_water(TAZ_ply, area_threshold = 0.5, year = 2020)

blk_groups_land <- tigris::erase_water(blk_group_ply, area_threshold = 0.5, year = 2020)

mapview(blk_groups_land) + mapview(TAZ_land, col.regions = "red")

# An alternative path to eliminating "all" water would be to use tigris::area_water() combined with gis operations to subtract it. To make the operations more performant, we could break things down at the county level. 
#tigris::area_water()
```

## Perform Intersections

### Intersections

```{r}
# The st_intersection command leaves us with "polygons", "lines", and "points" which turn into a "geometrycollection". Lines and points, by definition, have no area and we do not need them. Further, keeping them seems to slow things down. By using `st_collection_extract` we pull out only the piece we need--polygons.

intersections <- st_intersection(TAZ_land, blk_groups_land) %>%
  st_collection_extract("POLYGON") %>% 
  rowid_to_column("Intersection_ID") # unique ID for each intersection geometry

intersections$intersect_area <- st_area(intersections)

# mapview(TAZ_land, col.regions = "red") + mapview(blk_groups_land) + mapview(intersections, zcol = "Intersection_ID", legend = FALSE)

# Trying it out with a subset
# ss_intersection <- intersections %>% 
#   filter(ID == 4398) %>% 
#   st_as_sf() 
# ss_intersection$area <- st_area(ss_intersection)
# ss_intersection$pct_intersect <- ss_intersection$area / max(ss_intersection$area)
# 
# ss_intersection_final <- ss_intersection %>% 
#   filter(as.vector(pct_intersect) > 0.01)
# 
# plot(st_geometry(ss_intersection_final))


# Only keeping intersection areas for a TAZ that is at least 1% of the TAZ area 
# (could also make it 1% of the largest intersection area)
# intersections_clean <- intersections %>% 
#   group_by(ID) %>% 
#   mutate(pct_intersect = intersect_area / TAZ_area ) %>% 
#   filter(as.vector(pct_intersect) > 0.01) %>% 
#   ungroup() 

```

We can an explore an example in more detail.

```{r}
# Here's an example of an intersection.
example <- intersections %>% 
  filter(ID == 1759) 

mapview(TAZ_land |> 
          filter(ID %in% example$ID), 
        col.regions = "red", 
        layer.name = "TAZ") + 
  mapview(blk_groups_land |> 
            filter(GEOID %in% example$GEOID),
          alpha.regions = 0.01, lwd = 3,
          layer.name = "CBG") + 
  mapview(example, zcol = "Intersection_ID",
          layer.name = "Intersection")
```

### Different Method for Doing Intersections

This section was not used.

```{r}
#| eval: false
intersections_2 <- st_join(TAZ, cbfalse, 
                           join = st_intersects, 
                           largest = TRUE)
mapview(intersections_2) + mapview(TAZ)

# This method is not correct because it only pairs one TAZ with one block group, and also does not result in the geometry of the intersection, only the TAZ

```

## Look at Rooftop Share

#### Determine the Number of Rooftops in Each Intersection Area

We pull the pre-stored rooftops file in and show an example. Feel free to see how the file matches the footprints in the OSM layer and the aerial satellite layer.

```{r}
# rooftops.rds reated previously.
rooftops <- read_rds("./data/processed/rooftops.rds")
mapview(rooftops |> filter(STRUCT_ID == "53226_895084"))
```

We now find which rooftops are in which intersection area.

```{r}
#intersecting the rooftops with the census block groups
#roofs_in_bg <- st_intersection(blk_groups_land, rooftops)

# finding the number of rooftops in each census block group
# num_rooftops <- roofs_in_bg %>% 
#   group_by(GEOID) %>% 
#   mutate(num_roof = n()) %>%  
#   distinct(GEOID, num_roof)
# saveRDS(roofs_in_bg, "data/processed/rooftops_in_bg.rds")
# saveRDS(num_rooftops, "data/processed/num_rooftops.rds")

rooftops <- rooftops %>% 
  select(STRUCT_ID)

intersections <- intersections %>% 
  select(Intersection_ID, ID, GEOID, intersect_area)

# Joining the intersection areas with the rooftops that reside inside of them.
# 
# See this thread for the basic idea. The default join for 
# st_join is st_intersects, this is basically intersect the two and choose pull the info of the largest intersection area into the rooftop dataset.
# https://github.com/r-spatial/sf/issues/578

# This took a very long time
roofs_in_intersect <- st_join(
  rooftops,  
  intersections,
  left= FALSE, 
  largest = TRUE)

# Here's an example of what this is doing.
roofs_in_intersect_filt <- roofs_in_intersect |> 
  filter(ID %in% c(2708, 2709)) |> 
  mutate(Intersection_ID = as.character(Intersection_ID))

mapview(roofs_in_intersect_filt, zcol = "Intersection_ID") +
  mapview(intersections |> 
            filter(ID %in% roofs_in_intersect_filt$ID), 
          alpha.region = 0.01, layer.name = "Intersection")

# keeping the intersection area with the largest part of the rooftop
# roofs_in_intersect_clean <- roofs_in_intersect %>%
  # group_by(STRUCT_ID) %>% 
  # top_n(1)  

num_rooftops <- roofs_in_intersect %>% 
  st_drop_geometry() %>% 
  group_by(Intersection_ID) %>% 
  mutate(num_roof = n()) %>% 
  distinct(Intersection_ID, ID, GEOID, intersect_area, num_roof)

saveRDS(roofs_in_intersect, "data/processed/rooftops_in_intersect.rds")
saveRDS(num_rooftops, "data/processed/num_rooftops_intersect.rds")
```

#### Determine the percentage of population that belongs to each intersection in the TAZ based on the number of rooftops

```{r}
# Pull in the rooftops that were calculated in the last step.
roofs_in_intersect <- read_rds("./data/processed/rooftops_in_intersect.rds")

num_rooftops <-  read_rds("data/processed/num_rooftops_intersect.rds")

# Calculate the share of the GEOID in each TAZ.
num_rooftops <- num_rooftops |> 
  group_by(GEOID, ID) |> 
  summarize(num_roof = sum(num_roof)) |> 
  group_by(GEOID) |> 
  mutate(rooftop_pct = num_roof/sum(num_roof))

write_csv(num_rooftops, "./output/data/rooftop_share_plymouth.csv")
```

```{r}
# Get population for block groups
census_pop <- minority %>% 
  select(c(GEO_ID, P1_001N)) %>% 
  rename(GEOID = GEO_ID, population_BG = P1_001N)

census_pop$GEOID <-str_remove_all(census_pop$GEOID, "1500000US")

pop_percent <- num_rooftops %>% 
  group_by(GEOID) %>%
  # per BG: get percentage of rooftops that are in each intersecting TAZ
  mutate(population_pct = num_roof / sum(num_roof)) %>% 
  ungroup() %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = population_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_roof = sum(population_intersection)) %>% 
  ungroup()

TAZ_pop_rooftops <- pop_percent %>% 
  distinct(ID, population_TAZ_roof)

TAZ_plot <- TAZ_land %>% 
  left_join(TAZ_pop_rooftops)

mapview(TAZ_plot, zcol = "population_TAZ_roof")
```

## Look at Area Share

#### Land Area only

```{r}
# First step is to separate out water area in each of the intersections to determine what percentage of block group area should be applied to the population for that block group

TAZ_land$TAZ_land_area <- st_area(TAZ_land)
blk_groups_land$BG_area <- st_area(blk_groups_land) # could also just take ALAND

# Then, for each TAZ, the population of the intersected block groups should be added up.

intersections_AS <- st_intersection(TAZ_land, blk_groups_land) %>% 
  st_collection_extract("POLYGON") %>% 
  rowid_to_column("Intersection_ID") # unique ID for each intersection geometry

intersections_AS$intersect_area <- st_area(intersections_AS)

# Create the land area allocation table for export.
land_area_alloc <- intersections_AS %>% 
  st_drop_geometry() |> 
  select(Intersection_ID, ID, TAZ_land_area, GEOID, BG_area, intersect_area) %>%
  group_by(ID, GEOID, BG_area) %>%
  summarize(intersect_area = sum(intersect_area)) |> 
  group_by(GEOID) |> 
  # per BG: get percentage of land area that is in each intersecting TAZ
  mutate(land_area_pct = intersect_area / BG_area,
         land_area_pct = drop_units(land_area_pct))

write_csv(land_area_alloc, "./output/data/landarea_share_plymouth.csv")

land_areas <- intersections_AS %>% 
  select(Intersection_ID, ID, TAZ_land_area, 
         GEOID, BG_area, intersect_area) %>%
  group_by(GEOID) %>% 
  # per BG: get percentage of land area that is in each intersecting TAZ
  mutate(BG_land_pct = intersect_area / BG_area) %>% 
  ungroup() %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = BG_land_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_LA = drop_units(sum(population_intersection))) %>% 
  ungroup()

TAZ_pop_LandArea <- land_areas %>% 
  distinct(ID, population_TAZ_LA)



# Pct Difference between the two
diff <- TAZ_pop_rooftops %>% 
  left_join(TAZ_pop_LandArea) %>% 
  mutate(pct_diff = population_TAZ_roof / population_TAZ_LA )

hist(diff$pct_diff, 40)

```

#### Total Area

```{r}
blk_group_ply$BG_area <- st_area(blk_group_ply) # could also just take ALAND

# Then, for each TAZ, the population of the intersected block groups should be added up.

intersections_tot <- st_intersection(TAZ_ply, blk_group_ply) %>% 
  st_collection_extract("POLYGON") %>% 
  rowid_to_column("Intersection_ID") # unique ID for each intersection geometry

intersections_tot$intersect_area <- st_area(intersections_tot)

# Create the full area (land + water) allocation table for export.
tot_area_alloc <- intersections_tot %>%
  st_drop_geometry() |> 
  select(Intersection_ID, ID, TAZ_area, 
         GEOID, BG_area, intersect_area) %>%
  group_by(ID, GEOID, BG_area) %>%
  summarize(intersect_area = sum(intersect_area)) |> 
  group_by(GEOID) |> 
  # per BG: get percentage of all area that is in each intersecting TAZ
  mutate(all_area_pct = intersect_area / BG_area,
         all_area_pct = drop_units(all_area_pct))

write_csv(tot_area_alloc, "./output/data/allarea_share_plymouth.csv")

tot_areas <- intersections_tot %>% 
  select(Intersection_ID, ID, TAZ_area, GEOID, BG_area, intersect_area) %>%
  group_by(GEOID) %>% 
  # per BG: get percentage of all area that is in each intersecting TAZ
  mutate(BG_tot_pct = intersect_area / BG_area) %>% 
  ungroup() %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = BG_tot_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_totA = drop_units(sum(population_intersection))) %>% 
  ungroup()

TAZ_pop_TotArea <- tot_areas %>% 
  distinct(ID, population_TAZ_totA)

# Pct Difference between the two
diff <- TAZ_pop_TotArea %>% 
  left_join(TAZ_pop_LandArea) %>% 
  mutate(pct_diff = population_TAZ_totA / population_TAZ_LA )

hist(diff$pct_diff, 40)

```

## Join the Roofs, Land Area, All Area Methods

```{r}
# Join them all down here for exploration.
# Import the census block group pops once, then mutiply the populations here. 
```

### Testing

### Compare Population Estimates

```{r}

```

### Test minority share

```{r}

```

Thoughts:

-   some TAZs are smaller than blockgroups. Do we need to adjust the method of analysis for those cases? It could be the same. Since we are looking for the percentage of the block group that is within the TAZ, then it wouldn't matter if it is smaller or larger. In this case, it just wouldn't also be sharing area with other block groups.

    ![](images/image-779890944.png)

-   There are 17,000 intersection areas, meaning that the boundaries probably don't add up. Brought it down to 8843 by taking out the smallest intersection areas

-   Anything with the rooftops takes a very long time

-   the number of census block groups goes from 5116 to 5110, meaning there are 6 block groups with no rooftops. Also does not take into account if there are rooftops that intersect multiple blockgroups. For some reason, there are less unique IDs in roofs_in_cb than there are in rooftops, but the sum in num_rooftops is the same as the number of entries in roofs_in_cb
