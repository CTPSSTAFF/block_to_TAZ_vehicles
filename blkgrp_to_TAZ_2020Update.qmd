---
title: "Merging Blocks and TAZs"
author: "Sophie Fox and Steven Andrews"
date: "`r Sys.Date()`"
format: 
  html: 
    self-contained: true
editor: visual
---

**TODO**:

-   Remove duplicate rooftops: \`rooftops \|\> st_drop_geometry() \|\> group_by(STRUCT_ID) \|\> tally() \|\> filter(n\>1) \|\> View()\` Example: STRUCT_ID == "250858_862528". There are also STRUCT_IDs with values of "NA" that we should explore. Are they duplicate? Are they just unlabeled?
-   Remove vestigial commented out code. It's going to be confusing.
-   Export only the allocation table: GEOID, TAZ, share_of_geoid_to_TAZ_method1 (then repeat for methods 2 and 3). Once you're happy you can join them together to compare. In the end, we'll keep one method. We also want to be able to attach the dasymetric method later too.
-   Check the all area calc to see if the coast line is included. We really dont need that no matter what. It may just be a not great method and we dont worry much about it.
-   Check the number of CBG to TAZ relationships that exist. They ought to be the same(?) if we include 0% shares, which might not appear in a table.
-   Look at building footprints dataset for whole country by Microsoft- Emily

Notes:

-   You don't have to wrap select() arguments in c().
-   Using tidycensus gives you a cleaner table to start with rather than grabbing a flat file from the census and storing in in a folder. The end result should be the same.
-   You could do all the land area/rooftop/water area joins in one steps if you calc it at the start then keep track of it all. alternatively we can just keep this as is, then create a fresh notebook with the chosen solution.
-   

## General Goal

The TDM outputs results at a TAZ level. However, for equity analyses, we need to allocated census demographics to those TAZs--the model does not output results based on minority status, income status, or any other status that might be interesting for an equity analysis.

Census geometry does NOT fit neatly into TAZ geometry. We would like to allocate pieces of census demographics to surrounding TAZs to create demographics of the TAZs. We need to create a table that we can use to allocate portions of census geometry into TAZs.

**Problems:**

-   TAZs are mostly made up of blocks, but they're not exactly made up of blocks.
-   There are small tweaks to the TAZ geometry throughout the model region that mean lines do not overlap exactly.
-   Census blocks are NOT necessarily the best starting point because the differential privacy features of the 2020 census have rendered them unreliable.
-   TAZs may be smaller than a census geometry.

**Constraints:**

-   TAZ geometry may change over time. The process should be repeatable for arbitrary TAZ geometry (this essentially means for ANY geometry).

-   We want the process to be maintainable over multiple ACS iterations.

**Other Goals**

-   Create multiple methods to compare the sensitivity to methodology.

**Potential Solutions**

When joining 2010 census blocks to TAZs, Paul Reim performed a series of intersections to identify where blocks were split. Where a TAZ split a block, he counted rooftops and used StreetView to estimate how many rooftops were in each TAZ. It is not desirable to maintain such a process--the reproducibility is limited and its highly manual. We can replicate the methodology using the rooftops layer. There are other solutions available as well:

1.  Rooftops
    i.  Allocate based on where the largest piece of the rooftop is
    ii. Where the centroid of the roof is
    iii. Allocate proportionally based on the rooftop area.
2.  Land Area
3.  Total Area
4.  Dasymetric Mapping

### Useful references

-   massgis census: <https://www.mass.gov/info-details/massgis-data-2020-us-census>

-   MassDOT rooftops: <https://www.mass.gov/info-details/massgis-data-building-structures-2-d>

## Set up Packages

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(tidycensus)
library(tigris)
library(mapview)
library(sf)
library(units)
```

## Load Census, TAZ, and Rooftop Shapes

```{r}
#| results: hide
 
#Load TAZ shapes
TAZ <- sf::read_sf("J:/Shared drives/Data_Requests/TAZ_Shapefiles/R_Script/out/geopackage/TAZ19.gpkg") %>% 
  st_transform(26986) %>% 
  filter(STATE == "MA") # Filtering to only in MA

TAZ$TAZ_area <- st_area(TAZ)
  #filter(ID == 4398) # Filtering for one example

# OBtain the 2020 block_groups from the tigris package.
# The CB false (the more detailed) geometry looked like it matched up better, so we move forward with that path.
block_groups <- tigris::block_groups(state = "MA", 
                                cb = FALSE, 
                                year = 2020) %>% 
  st_transform(26986)

# Clip the block_groups to match the geometry of the TAZ file. This will eliminate coastal waters but retain inland waters. This is a useful starting place to have a similar coast line. This will also make our `erase_water` function work on a more similar set of water.

block_groups_nocoast <- 
  st_intersection(block_groups, TAZ |> summarize()) |> 
  st_collection_extract("POLYGON")

# Review the differences. It looks like what we'd expect. Coastal waters are not in the dataset anymore. 
# mapview(block_groups) + 
# mapview(block_groups_nocoast , col.regions = "orange")

# Overwrite the original file with the no_coast version and clean up the workspace.
block_groups <- block_groups_nocoast
rm(block_groups_nocoast)

#massgis rooftops: https://www.mass.gov/info-details/massgis-data-building-structures-2-d
# Download the file into "./data/base/" and then read it in here. Save it as a .rds for easy loading. Optionally, we could 
# rooftops <- st_read("data/base/STRUCTURES_POLY.shp")
# 
# saveRDS(rooftops, "data/processed/rooftops.rds")


# Load Population Census Data
# downloaded from: https://data.census.gov/table?t=Race+and+Ethnicity&g=0400000US25$1500000&tid=DECENNIALPL2020.P1
# minority <- read_csv("data/base/DECENNIALPL2020.P1-Data.csv")

# P2_005N: Non-Hispanic/Latino, White-alone.
# P1_001N: Total Population.
minority_tidy <- tidycensus::get_decennial(
  geography = "block group",
  state = "MA",
  variable = "P2_005N",
  summary_var = "P1_001N",
  year = 2020)

```

### Filter for Plymouth County

We start by filtering out for just Plymouth County to keep the problem small while we work through the process.

```{r}
# ply = Plymouth.
TAZ_ply <- TAZ %>% 
  filter(COUNTY == "Plymouth MA")

# 023 = Plymouth
# See: tidycensus::fips_codes |> filter(state == "MA", county_code == "023")
blk_group_ply <- block_groups %>% 
  filter(COUNTYFP == "023") %>% 
  group_by(GEOID) %>% 
  summarize()

rm(TAZ, block_groups)
```

## Calculate Intersecting Areas

### Find Area of census block groups

We find the area of the census block groups. This area will not necessarily match areas reported by the census because of how the coastline is handled and how inland water is handled.

```{r}
blk_group_ply$BG_TOTAL_AREA <- (st_area(blk_group_ply) ) 
```

### Intersect census block groups with TAZ

```{r}

intersections <- st_intersection(TAZ_ply, blk_group_ply) %>%
  st_collection_extract("POLYGON") %>% 
  rowid_to_column("Intersection_ID") # unique ID for each intersection geometry

intersections$INTERSECTION_TOTAL_AREA <- st_area(intersections)
```

We now have the full area of the CBGs and the area of the intersections.

### Erase Water From Intersections

We can now remove the water from the intersections. By doing this now, we only remove the water area once.

```{r}
intersections_land <- tigris::erase_water(intersections, 
                                area_threshold = 0.5, 
                                year = 2020)
```

### Recalculate Land Area for the Intersections

We can now recalculate the area to obtain the land area by intersection.

```{r}
intersections_land$INTERSECTION_LAND_AREA <- st_area(intersections_land)
```

### Find Total Land Area for Census Block Groups

```{r}
intersections_land <- intersections_land %>% 
  group_by(GEOID) %>% #grouping by block group
  mutate(BG_LAND_AREA = sum(INTERSECTION_LAND_AREA))
```

For each intersection area we now have the full area, the land area, the full area of the CBG and the land area of the CBG.

### Rejoin to initial intersection dataset

Bring the full dataset back together. We need to join back to the original intersection to maintain all of the "full area". Some of the areas disappear after water is removed. Without these the areas are not fully accounted for.

```{r}
intersections_for_alloc <- intersections |>
  st_drop_geometry() |>
  select(Intersection_ID, ID, GEOID, 
         INTERSECTION_TOTAL_AREA, BG_TOTAL_AREA) |>
  left_join(
    intersections_land |> 
      st_drop_geometry() |> 
      select(Intersection_ID, ID, GEOID, 
             INTERSECTION_LAND_AREA, BG_LAND_AREA),
    join_by(Intersection_ID, ID, GEOID)) 
```

## Allocate CBGs to TAZs

### Allocate based on Area

This calculated the relationship between CBGs and TAZs based on land area (LA) and full area (FA). The full area method does have coastal waters stripped away.

```{r}
area_allocation <- intersections_for_alloc |> 
  group_by(GEOID) |> 
    mutate(BG_LA_pct = drop_units(INTERSECTION_LAND_AREA / BG_LAND_AREA),
           BG_FA_pct = drop_units(INTERSECTION_TOTAL_AREA / BG_TOTAL_AREA) # FA = Full Area.
           ) |> 
  select(Intersection_ID, ID, GEOID, 
         BG_LA_pct, BG_FA_pct )


write_csv(area_allocation, "./output/data/all_allocation_plymouth.csv")
```

#### Check Results

We want to verify that we have maintained area. We want 100% of the area accounted for.

```{r}
area_allocation |> group_by(GEOID) |> 
  summarize(tot_LA_in_CBG = sum(BG_LA_pct, na.rm = TRUE),
            tot_FA_in_CBG = sum(BG_FA_pct, na.rm = TRUE)) |>
  ungroup() |> 
  filter(tot_FA_in_CBG < 0.999 | tot_LA_in_CBG < 0.999)
```

Land area is good. All of the CBG area is accounted for. For the full area method there are some small areas where the TAZ geometry and the CBG geometry does not exactly line up. This appears to be the cause of some small discrepancies in the "full area" method. They appear to be very small \<1%. In the Plymouth county example, some islands off the coast of Hull appear to be missing. These islands are in \`TAZ\$ID == 399\` outside Plymouth County.

##### Explore Areas

```{r}

example <- intersections %>% 
  filter(GEOID == 250235001032)

mapview(TAZ_ply |> 
          filter(ID %in% example$ID), 
        col.regions = "red", 
        layer.name = "TAZ") + 
  mapview(blk_group_ply |> 
            filter(GEOID %in% example$GEOID),
          alpha.regions = 0.01, lwd = 3,
          layer.name = "CBG") + 
  mapview(example, zcol = "Intersection_ID",
          layer.name = "Intersection")
```

### Allocate based on rooftops

We want to find the intersection of rooftops and the CBGs and TAZs.

We pull the pre-stored rooftops file in and show an example. The file generally matches the footprints in the OSM layer and the aerial satellite layer.

```{r}
# rooftops.rds reated previously.
rooftops <- read_rds("./data/processed/rooftops.rds")
mapview(rooftops |> filter(STRUCT_ID == "53226_895084"))
```

#### Looking at repeated and NA IDs for rooftops

```{r}

# Find the IDs of repeats and how many times they are repeated
repeats <- rooftops |> st_drop_geometry() |> group_by(STRUCT_ID) |> tally() |> filter(n>1)
View(repeats)

# Find the rooftops with unique STRUCT_IDs
unique_roof <- rooftops %>% filter(!(STRUCT_ID %in% repeats$STRUCT_ID)) %>% 
  select(STRUCT_ID, geometry)
# Find the rooftops with repeated or NA STRUCT_IDs
repeat_roof <- rooftops %>% filter(STRUCT_ID %in% repeats$STRUCT_ID) %>% 
  select(STRUCT_ID, geometry)

# All NAs will be replaced by a new id
repeat_roof <- repeat_roof |>
  mutate(STRUCT_ID = coalesce(STRUCT_ID, paste0(row_number(), "_replaced_na")))

# Summarizing to get new geometry
repeat_roof <- repeat_roof %>% 
  group_by(STRUCT_ID) %>% 
  summarize() 

mapview(repeat_roof)

# combining the rooftops with unique ids with new summarized roof geometries
final_roofs <- bind_rows(unique_roof, repeat_roof)

rm(rooftops)

# Some of the repeats are where there are buildings for schools, like UMass Boston
# Others are where there are multiple polygons that have the same struct ID and just look like a main building with an extra attachment.  

# Option 1: summarize repeats and add back into no duplicates
# Option 2: Go through manually and take the largest

#NA_rooftops <- rooftops %>% 
#  filter(is.na(STRUCT_ID) == TRUE)
#x <- head(NA_rooftops,1)
#mapview(x)
# NA struct IDs seem to be random
```

#### Find which CBG and which TAZ each rooftop is most in

1\) Intersect with CBGs
2\) intersect with TAZs.

```{r}
tictoc::tic()
roof_cbg <- st_join(
  final_roofs,
  blk_group_ply |> select(GEOID),
  left = FALSE,
  largest = TRUE
) |> st_drop_geometry()
tictoc::toc()

tictoc::tic()
roof_taz <- st_join(
  final_roofs |>
    filter(STRUCT_ID %in% roof_cbg$STRUCT_ID),
  TAZ_ply |> select(ID),
  left = FALSE,
  largest = TRUE
)|> st_drop_geometry()
tictoc::toc()

# Make a single table where each rooftop is assigned to the CBG its most in and the TAZ its most in.

tictoc::tic()
roof_shares <- final_roofs |> 
  filter(STRUCT_ID %in% roof_cbg$STRUCT_ID) |> 
  left_join(roof_cbg, by = "STRUCT_ID") |> 
  left_join(roof_taz, by = "STRUCT_ID")
tictoc::toc()

# saveRDS(roof_cbg, "./data/processed/roof_cbg.rds")
# saveRDS(roof_taz, "./data/processed/roof_taz.rds")
# saveRDS(roof_shares, "./data/processed/roof_shares.rds")

# roof_cbg <- readRDS("./data/processed/roof_cbg.rds")
# roof_taz <- readRDS("./data/processed/roof_taz.rds")
# roof_cbg <- readRDS("./data/processed/roof_cbg.rds")

tictoc::tic()
roof_shares_ratio <- roof_shares |> 
  st_drop_geometry() |> 
  group_by(GEOID,ID) |> 
  summarize(tot_roofs = n()) |> 
  group_by(GEOID) |> 
  mutate(pct = tot_roofs/sum(tot_roofs))
tictoc::toc()

write_csv(roof_shares_ratio, file = "./output/data/rooftop_share_plymouth_largest_in_each.csv")

```

```{r}

example <- roof_shares %>% 
  filter(GEOID == 250235001011)

mapview(TAZ_ply |> 
          filter(ID %in% example$ID), 
        col.regions = "red", 
        layer.name = "TAZ") + 
  mapview(blk_group_ply |> 
            filter(GEOID %in% example$GEOID),
          alpha.regions = 0.01, lwd = 3,
          layer.name = "CBG") + 
  mapview(example, zcol = "STRUCT_ID",
          layer.name = "Roof")
```

We now find which rooftops are in which intersection area.

```{r}
#intersecting the rooftops with the census block groups
#roofs_in_bg <- st_intersection(blk_groups_land, rooftops)

# finding the number of rooftops in each census block group
# num_rooftops <- roofs_in_bg %>% 
#   group_by(GEOID) %>% 
#   mutate(num_roof = n()) %>%  
#   distinct(GEOID, num_roof)
# saveRDS(roofs_in_bg, "data/processed/rooftops_in_bg.rds")
# saveRDS(num_rooftops, "data/processed/num_rooftops.rds")


intersections_land <- intersections_land %>% 
  select(Intersection_ID, ID, GEOID, BG_TOTAL_AREA, INTERSECTION_TOTAL_AREA, INTERSECTION_LAND_AREA, BG_LAND_AREA)

# Joining the intersection areas with the rooftops that reside inside of them.
# 
# See this thread for the basic idea. The default join for 
# st_join is st_intersects, this is basically intersect the two and choose pull the info of the largest intersection area into the rooftop dataset.
# https://github.com/r-spatial/sf/issues/578


# NOTE: have to rethink the join to account for total bg area as opposed to the largest intersection area (see Jamboard)
# https://jamboard.google.com/d/1L5YrUrmOUpmQp8X6w2gaz51Fz6We8b0uV-Hm5g4aU2E/viewer?ts=63d15e99&f=1
# This took a very long time
roofs_in_intersect <- st_join(
  final_roofs,  
  intersections_land,
  left= FALSE, # inner join
  largest = TRUE)

# Here's an example of what this is doing.
roofs_in_intersect_filt <- roofs_in_intersect |> 
  filter(ID %in% c(2708, 2709)) |> 
  mutate(Intersection_ID = as.character(Intersection_ID))

mapview(roofs_in_intersect_filt, zcol = "Intersection_ID") +
  mapview(intersections |> 
            filter(ID %in% roofs_in_intersect_filt$ID), 
          alpha.region = 0.01, layer.name = "Intersection")

num_rooftops <- roofs_in_intersect %>% 
  st_drop_geometry() %>% 
  group_by(Intersection_ID) %>% 
  mutate(num_roof = n()) %>% 
  distinct(Intersection_ID, ID, GEOID, BG_TOTAL_AREA, BG_LAND_AREA, INTERSECTION_TOTAL_AREA, INTERSECTION_LAND_AREA, num_roof)

saveRDS(roofs_in_intersect, "data/processed/rooftops_in_intersect.rds")
saveRDS(num_rooftops, "data/processed/num_rooftops_intersect.rds")
```

Looking to see how many rooftops are in multiple intersections

```{r}
roofs_in_intersect2 <- st_join(
  final_roofs,  
  intersections_land,
  left= FALSE) %>% 
  group_by(STRUCT_ID) %>% 
  mutate(num_intersections = n()) 

roofs_in_intersect2 <- roofs_in_intersect2 %>% 
  distinct(STRUCT_ID, num_intersections) %>% 
  filter(num_intersections > 1)

# 4 intersections: 6 rooftops
# 3 intersections: 133 rooftops
# 2 intersections: 90 rooftops
# Percent of rootops (240492) that are in 3+ intersections: 0.058%
  
```

#### Determine the percentage of population that belongs to each intersection in the TAZ based on the number of rooftops

```{r}
# Pull in the rooftops that were calculated in the last step.
roofs_in_intersect <- read_rds("./data/processed/rooftops_in_intersect.rds")

num_rooftops <-  read_rds("data/processed/num_rooftops_intersect.rds")

# Calculate the share of the GEOID in each TAZ.
rooftop_share <- num_rooftops |> 
  group_by(GEOID) |>  
  mutate(rooftop_pct = num_roof/sum(num_roof))

write_csv(rooftop_share, "./output/data/rooftop_share_plymouth.csv")
```

```{r}
# Get population for block groups
census_pop <- minority_tidy %>% 
  select(c(GEOID, summary_value)) %>% 
  rename(population_BG = summary_value)

census_pop$GEOID <-str_remove_all(census_pop$GEOID, "1500000US")

pop_percent <- rooftop_share %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = rooftop_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_roof = sum(population_intersection)) %>% 
  ungroup()

TAZ_pop_rooftops <- pop_percent %>% 
  distinct(ID, population_TAZ_roof)

TAZ_plot <- TAZ_ply %>% 
  left_join(TAZ_pop_rooftops)

mapview(TAZ_plot, zcol = "population_TAZ_roof")
```

## Review Population Effects

#### Land Area

```{r}

land_areas <- land_area_alloc %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = BG_LA_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_LA = sum(population_intersection)) %>% 
  ungroup()

TAZ_pop_LandArea <- land_areas %>% 
  distinct(ID, population_TAZ_LA)

TAZ_plot <- TAZ_plot %>% 
  left_join(TAZ_pop_LandArea)


mapview(TAZ_plot, zcol = "population_TAZ_LA")

```

#### Total Area

This performs an intersection and allocation between CBGs and TAZs based on all area, including water area.

```{r}

tot_areas <- tot_area_alloc %>% 
  left_join(census_pop) %>% 
  # per BG: get population in each intersecting TAZ
  mutate(population_intersection = BG_AA_pct * as.numeric(population_BG)) %>% 
  group_by(ID) %>% 
  # per TAZ: add up the population in each intersecting BG
  mutate(population_TAZ_AA = sum(population_intersection)) %>% 
  ungroup()

TAZ_pop_TotArea <- tot_areas %>% 
  distinct(ID, population_TAZ_AA)


TAZ_plot_FINAL <- TAZ_plot %>% 
  left_join(TAZ_pop_TotArea)


mapview(TAZ_plot_FINAL, zcol = "population_TAZ_AA")



# Pct Difference between the two
diff <- TAZ_pop_TotArea %>% 
  left_join(TAZ_pop_LandArea) %>% 
  mutate(pct_diff = population_TAZ_AA / population_TAZ_LA )

ggplot(diff, aes(x = pct_diff)) +
  geom_histogram(binwidth = 0.25) +
  scale_x_continuous(breaks = seq(0,25,1))

hist(diff$pct_diff, 80)

```

## Dasymetric Allocation

```{r}

```

## Join the Roofs, Land Area, All Area Methods

```{r}
# Join them all down here for exploration.

joined_estimates <- TAZ_pop_rooftops %>% 
  left_join(TAZ_pop_LandArea) %>% 
  left_join((TAZ_pop_TotArea))

# Import the census block group pops once, then mutiply the populations here. 
```

### Testing

### Compare Population Estimates

```{r}
```

### Test minority share

```{r}

```

Thoughts:

-   some TAZs are smaller than blockgroups. Do we need to adjust the method of analysis for those cases? It could be the same. Since we are looking for the percentage of the block group that is within the TAZ, then it wouldn't matter if it is smaller or larger. In this case, it just wouldn't also be sharing area with other block groups.

    ![](images/image-779890944.png)
