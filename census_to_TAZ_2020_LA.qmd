---
title: "Merging Census Tracts and TAZs"
author: "Sophie Fox and Steven Andrews"
date: "`r Sys.Date()`"
format: 
  html: 
    self-contained: true
editor: visual
---

## General Goal

The TDM outputs results at a TAZ level. However, for equity analyses, we need to allocated census demographics to those TAZs--the model does not output results based on minority status, income status, or any other status that might be interesting for an equity analysis.

Census geometry does NOT fit neatly into TAZ geometry. We would like to allocate pieces of census demographics to surrounding TAZs to create demographics of the TAZs. We need to create a table that we can use to allocate portions of census geometry into TAZs.

**Problems:**

-   TAZs are mostly made up of census tracts, but they're not exactly made up of tracts.
-   There are small tweaks to the TAZ geometry throughout the model region that mean lines do not overlap exactly.
-   Census blocks are NOT necessarily the best starting point because the differential privacy features of the 2020 census have rendered them unreliable.
-   TAZs may be smaller than a census geometry.

**Constraints:**

-   TAZ geometry may change over time. The process should be repeatable for arbitrary TAZ geometry (this essentially means for ANY geometry).

-   We want the process to be maintainable over multiple ACS iterations.

**Potential Solutions**

When joining 2010 census blocks to TAZs, Paul Reim performed a series of intersections to identify where blocks were split. Where a TAZ split a block, he counted rooftops and used StreetView to estimate how many rooftops were in each TAZ. It is not desirable to maintain such a process--the reproducibility is limited and its highly manual.

We have decided to focus on **land area** as the method to allocate census populations to different TAZs.

### Useful references

-   massgis census: <https://www.mass.gov/info-details/massgis-data-2020-us-census>

## Set up Packages

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(tidycensus)
library(tigris)
library(mapview)
library(sf)
library(units)
library(rgeos)
library(sp)
library(mapview)
library(leafsync)
library(ggplot2)
library(dplyr)
```

## Load Census and TAZ

```{r}
#| results: hide
 
source("Functions/Census_to_TAZ_functions.R")


#Load TAZ shapes
TAZ <- sf::read_sf("J:/Shared drives/Data_Requests/TAZ_Shapefiles/R_Script/out/geopackage/TAZ19.gpkg") %>% 
  st_transform(26986) %>% 
  filter(STATE %in% c("MA", "RI", "NH")) %>% # Filtering to only in MA, RI, and NH
  filter(TAZ_TYPE == "Internal_Centroid")
  
TAZ$TAZ_area <- st_area(TAZ)
  #filter(ID == 4398) # Filtering for one example

# OBtain the 2020 tracts and block groups from the tigris package.
# The CB false (the more detailed) geometry looked like it matched up better, so we move forward with that path.

# functions
tracts <- region_tracts(2020, TAZ)
BG <- region_bg(2020, TAZ)

mapview(tracts)
mapview(BG)

# saveRDS(tracts, "data/processed/tracts.rds")
# saveRDS(BG, "data/processed/BG.rds")

tracts <- readRDS("data/processed/tracts.rds")
BG <- readRDS("data/processed/BG.rds")

```

## Calculate Intersecting Areas

### Find Area of Census Tracts/Block Groups

We find the area of the census tracts and block groups. This area will not necessarily match areas reported by the census because of how the coastline is handled and how inland water is handled.

```{r}
tracts$TRACT_TOTAL_AREA <- (st_area(tracts))
BG$BG_TOTAL_AREA <- (st_area(BG))
```

### Intersect Census Tracts & Block Groups with TAZ

```{r}
# Intersection_func function
intersections_tract <- intersection_func(TAZ, geog = tracts)
intersections_BG <- intersection_func(TAZ, geog = BG)

# saveRDS(intersections_tract, "data/processed/intersect_tract.rds")
# saveRDS(intersections_BG, "data/processed/intersect_BG.rds")

intersections_tract <- readRDS("data/processed/intersect_tract.rds")
intersections_BG <- readRDS("data/processed/intersect_BG.rds")
```

We now have the full area of the tracts and the area of the intersections.

### Erase Water From Intersections

We can now remove the water from the intersections. By doing this now, we only remove the water area once. We eliminate all of the water area.

```{r}
water <-
  area_water(
    state = "MA",
    year = 2020,
    county = fips_codes |> 
      filter(state == "MA") |> 
      select(county_code) |> pull()
  ) |> st_drop_geometry()

# Sort our water find the share of the area and the percentile of each body of water.
water <- water |> 
  arrange(desc(AWATER)) |> 
  mutate(share_of_area = cumsum(AWATER)/sum(AWATER),
         ntile = row_number()/n())

ggplot(water, aes(x= ntile, y = share_of_area)) + 
  geom_point() +
  scale_x_continuous(labels = scales::percent_format()) +
  scale_y_continuous(labels = scales::percent_format()) +
  coord_cartesian(xlim = c(0,0.25))
```

```{r}

intersections_tract_land <- tigris::erase_water(intersections_tract, 
                                area_threshold = 0.8, 
                                year = 2020)

intersections_BG_land <- tigris::erase_water(intersections_BG, 
                                area_threshold = 0.8, 
                                year = 2020)



# saveRDS(intersections_tract_land, "data/processed/intersections_tract_land.rds")
# saveRDS(intersections_BG_land, "data/processed/intersections_BG_land.rds")

intersections_tract_land <- readRDS("data/processed/intersections_tract_land.rds")
intersections_BG_land <- readRDS("data/processed/intersections_BG_land.rds")
```

### Recalculate Land Area for the Intersections

We can now recalculate the area to obtain the land area by intersection.

```{r}
# tract
intersections_tract_land$INTERSECTION_LAND_AREA <- st_area(intersections_tract_land)

# bg
intersections_BG_land$INTERSECTION_LAND_AREA <- st_area(intersections_BG_land)
```

### Find Total Land Area for Census Tracts / Block Group

```{r}
# tract
intersections_tract_land <- intersections_tract_land %>% 
  group_by(GEOID) %>% #grouping by tract
  mutate(TRACT_LAND_AREA = sum(INTERSECTION_LAND_AREA))

# bg
intersections_BG_land <- intersections_BG_land %>% 
  group_by(GEOID) %>% #grouping by BG
  mutate(BG_LAND_AREA = sum(INTERSECTION_LAND_AREA))
```

For each intersection area we now have the land area and the full area of the tract/BG and the land area of the tract/BG.

### Rejoin to initial intersection dataset

Bring the full dataset back together. We need to join back to the original intersection to maintain all of the "full area". Some of the areas disappear after water is removed. Without these the areas are not fully accounted for.

```{r}

# tract
intersections_for_alloc_tract <- intersections_tract |>
  st_drop_geometry() |>
  select(Intersection_ID, ID, GEOID, 
         INTERSECTION_TOTAL_AREA, TRACT_TOTAL_AREA) |>
  left_join(
    intersections_tract_land |> 
      st_drop_geometry() |> 
      select(Intersection_ID, ID, GEOID, 
             INTERSECTION_LAND_AREA, TRACT_LAND_AREA),
    by = c("Intersection_ID", "ID", "GEOID")) 

# Note: there are instances where the intersection total area is less than than the intersection land area

# bg
intersections_for_alloc_BG <- intersections_BG |>
  st_drop_geometry() |>
  select(Intersection_ID, ID, GEOID, 
         INTERSECTION_TOTAL_AREA, BG_TOTAL_AREA) |>
  left_join(
    intersections_BG_land |> 
      st_drop_geometry() |> 
      select(Intersection_ID, ID, GEOID, 
             INTERSECTION_LAND_AREA, BG_LAND_AREA),
    by = c("Intersection_ID", "ID", "GEOID"))

```

## Allocate Tracts/Block Groups to TAZs

### Allocate based on Area

This calculated the relationship between tracts/block groups and TAZs based on land area (LA) and full area (FA). The full area method does have coastal waters stripped away.

```{r}

# tract
area_allocation_tract <- intersections_for_alloc_tract |> 
  group_by(GEOID) |> 
    mutate(TRACT_LA_pct = 
             drop_units(INTERSECTION_LAND_AREA / TRACT_LAND_AREA)) |> 
  select(Intersection_ID, ID, GEOID, 
         TRACT_LA_pct) |> 
  group_by(GEOID, ID) |> 
  summarize(TRACT_LA_pct = sum(TRACT_LA_pct, na.rm = TRUE)) |> 
  filter(ID %in% TAZ$ID)


# bg
area_allocation_BG <- intersections_for_alloc_BG |> 
  group_by(GEOID) |> 
    mutate(BG_LA_pct = 
             drop_units(INTERSECTION_LAND_AREA / BG_LAND_AREA)) |> 
  select(Intersection_ID, ID, GEOID, 
         BG_LA_pct) |> 
  group_by(GEOID, ID) |> 
  summarize(BG_LA_pct = sum(BG_LA_pct, na.rm = TRUE)) |> 
  filter(ID %in% TAZ$ID)

write_csv(area_allocation_tract, "output/data/area_allocation_tract.csv")
write_csv(area_allocation_BG, "output/data/area_allocation_BG.csv")
```

#### Check Results

We want to verify that we have maintained area. We want 100% of the area accounted for. This may be not as true now that we've included extra buffer area. We may want 100% of the area included for the TAZs inside the MPO boundary.

```{r}

# tract
flag_tract <- area_allocation_tract |> 
  group_by(GEOID) |> 
  summarize(tot_LA_in_tract = sum(TRACT_LA_pct, na.rm = TRUE)) |>
  ungroup() |> 
  filter(tot_LA_in_tract < 0.999)

# bg
flag_BG <- area_allocation_BG |> 
  group_by(GEOID) |> 
  summarize(tot_LA_in_BG = sum(BG_LA_pct, na.rm = TRUE)) |>
  ungroup() |> 
  filter(tot_LA_in_BG < 0.999)
```

There are three land_area values that are equal to `0`, rather than `1`. T

##### Explore Areas

```{r}
example <- intersections %>% 
  filter(GEOID %in% flag$GEOID)
  # filter(GEOID == "250277612002")

mapview(TAZ |> 
          filter(ID %in% example$ID), 
        col.regions = "red", 
        layer.name = "TAZ") + 
  mapview(tracts |> 
            filter(GEOID %in% example$GEOID),
          alpha.regions = 0.01, lwd = 3,
          layer.name = "tracts") + 
  mapview(example, zcol = "Intersection_ID",
          layer.name = "Intersection") + 
  mapview(TAZ |> st_union())
```

## Finding TAZ Results

```{r}

# tract
area_tracts <- read_csv("output/data/area_allocation_tract.csv",
                 show_col_types = FALSE)

allocation_results_tracts <- area_tracts %>%
  filter(ID %in% TAZ$ID)
write_csv(allocation_results_tracts, "output/data/allocation_results_tract.csv")


# bg
area_BG <- read_csv("output/data/area_allocation_BG.csv",
                 show_col_types = FALSE)

allocation_results_BG <- area_BG %>%
  filter(ID %in% TAZ$ID)
write_csv(allocation_results_BG, "output/data/allocation_results_BG.csv")

# Note: I don't think the above does anything



# Import the census tract info for MA. 

# min_data function
minority_acs_tract <- min_data("tract")
minority_acs_BG <- min_data("block group")



# Join the population to the tracts.
# Find the minority percentages and their moes for each TAZ.
# 
# Note: We reviewed using the boundaries of the MOEs scaled by the coverage, but
# it had issues with values going under 0 in strange ways, the MOEs seemed smaller
# than the moe_sum/prop methods, which seemed like an undesirable choice given
# the other assumptions going on throughout the process. We choose the more straight
# forward method for simplicity. 

# tract
TAZ_results_tract <- allocation_results_tracts |> 
  left_join(minority_acs_tract, by = "GEOID") %>% 
  # multiply area allocation percentages by estimates
  mutate(nonmin_alloc = TRACT_LA_pct * nonmin_pop,
         tot_alloc = TRACT_LA_pct * tot_pop) %>% 
  # and for the moes
  mutate(nonmin_moe_alloc = TRACT_LA_pct * nonmin_moe,
         tot_moe_alloc = TRACT_LA_pct * tot_moe)

# bg
TAZ_results_BG <- allocation_results_BG |> 
  left_join(minority_acs_BG, by = "GEOID") %>% 
  # multiply area allocation percentages by estimates
  mutate(nonmin_alloc = BG_LA_pct * nonmin_pop,
         tot_alloc = BG_LA_pct * tot_pop) %>% 
  # and for the moes
  mutate(nonmin_moe_alloc = BG_LA_pct * nonmin_moe,
         tot_moe_alloc = BG_LA_pct * tot_moe)


# sum up estimates and moes for each TAZ
TAZ_results_summ_tract <- results_summ(TAZ_results_tract)
TAZ_results_summ_BG <- results_summ(TAZ_results_BG)

plot(TAZ_results_summ_tract$min_pct, TAZ_results_summ_BG$min_pct)

ggplot(data = data.frame(x = TAZ_results_summ_tract$min_pct, y = TAZ_results_summ_BG$min_pct), aes(x = x, y = y)) + geom_point(alpha = 0.2) + coord_equal() + labs(x = "tract", y = "bg")+ geom_abline( slope=1, color = "red")

min_comp <- TAZ_results_summ_tract %>% 
  select(ID, tract_nonmin = TAZ_nonmin, tract_tot = TAZ_tot, tract_min_pct = min_pct) %>% 
  left_join(TAZ_results_summ_BG, by = "ID") %>% 
  rename(BG_min_pct = min_pct, BG_nonmin = TAZ_nonmin, BG_tot = TAZ_tot) %>% 
  select(-c(n, TAZ_nonmin_moe, TAZ_tot_moe, min_pct_moe, combined_moe_pct)) %>% 
  mutate(diff_minpct = abs(tract_min_pct - BG_min_pct ))

write_csv(min_comp, "output/data/minority_comparison.csv")

outliers <- TAZ %>% 
  left_join(min_comp, by = "ID") %>% 
  filter(diff > 0.2)
 
mapview(outliers, zcol = "diff") + mapview(tracts) + mapview(BG)

ggplot(data = data.frame(x = min_comp$tract_tot, y = min_comp$BG_tot), aes(x = x, y = y)) + geom_point(alpha = 0.2) + coord_equal() + labs(x = "tract", y = "bg")+ geom_abline( slope=1, color = "red")


library(GGally)
ggpairs(min_comp, title="Correlogram For Min Pct") 



```

### Testing VRE Method for Finding Margin of Error

```{r}

# VRE tables downloaded from https://www2.census.gov/programs-surveys/acs/replicate_estimates/2021/data/5-year/140/
# B03002_25.csv: 25 is for MA

VRE_table <- read_csv("data/base/B03002_25.csv") %>% 
  filter(ORDER %in% c(1,3)) %>% 
  select(GEOID, ORDER, ESTIMATE, starts_with("Var_Rep"))

VRE_table$GEOID <- as.numeric(str_remove_all(VRE_table$GEOID, "1400000US"))

VRE_nonmin <- VRE_table %>% 
  filter(ORDER == 3)

VRE_tot <- VRE_table %>% 
  filter(ORDER == 1)

alloc <- function(x) (x * allocation_results$TRACT_LA_pct) # is allocation results right to use here?

# allocation sums 
VRE_nonmin_results <- allocation_results |> 
  left_join(VRE_nonmin, by = "GEOID") %>% 
  mutate(ESTIMATE = ESTIMATE * TRACT_LA_pct) %>% 
  mutate_at(vars(matches("Var_Rep")), alloc) %>% 
  group_by(ID) %>% 
  summarise_at(vars(4:84), sum , na.rm = TRUE)

VRE_tot_results <- allocation_results |> 
  left_join(VRE_tot, by = "GEOID") %>% 
  mutate(ESTIMATE = ESTIMATE * TRACT_LA_pct) %>% 
  mutate_at(vars(matches("Var_Rep")), alloc) %>% 
  group_by(ID) %>% 
  summarise_at(vars(4:84), sum , na.rm = TRUE)

# Differences
diff_nonmin <- function(x) (x - VRE_nonmin_results$ESTIMATE)
diff_tot <- function(x) (x - VRE_tot_results$ESTIMATE)

square <- function(x) (x ^ 2)

VRE_nonmin_diffsq <-  VRE_nonmin_results %>% 
  mutate_at(vars(matches("Var_Rep")), diff_nonmin) %>% 
  mutate_at(vars(matches("Var_Rep")), square) 
  
VRE_tot_diffsq <-  VRE_tot_results %>% 
  mutate_at(vars(matches("Var_Rep")), diff_tot) %>% 
  mutate_at(vars(matches("Var_Rep")), square) 

# sum
VRE_nonmin_diffsq$VRE_sum <- rowSums(VRE_nonmin_diffsq[c(3:82)], na.rm = TRUE)
VRE_tot_diffsq$VRE_sum <- rowSums(VRE_tot_diffsq[c(3:82)], na.rm = TRUE)

# Variance and MOE

VRE_nonmin_var <- VRE_nonmin_diffsq %>% 
  select(ID,EST_nonmin =  ESTIMATE, VRE_sum_nonmin = VRE_sum) %>% 
  mutate(variance_nonmin = VRE_sum_nonmin * (4/80)) %>% 
  mutate(MOE_nonmin = 1.645 * sqrt(variance_nonmin) )

VRE_tot_var <- VRE_tot_diffsq %>% 
  select(ID,EST_tot =  ESTIMATE, VRE_sum_tot = VRE_sum) %>% 
  mutate(variance_tot = VRE_sum_tot * (4/80)) %>% 
  mutate(MOE_tot = 1.645 * sqrt(variance_tot) )

# Find the percent minority and moe
VRE_combined <- VRE_nonmin_var %>% 
  left_join(VRE_tot_var) %>% 
  mutate(nonmin_pct = EST_nonmin / EST_tot, 
         VRE_min_pct = 1 - nonmin_pct) %>% 
  select(-nonmin_pct) %>%  
  mutate(VRE_min_pct_moe = moe_prop(num = EST_nonmin, denom = EST_tot, 
                               moe_num = MOE_nonmin, moe_denom = MOE_tot))  %>% 
  mutate(VRE_combined_moe_pct = paste0(scales::percent(VRE_min_pct, 0.1), 
                                   " ± ", 
                                   scales::percent(VRE_min_pct_moe, 0.1)))

# Compare with earlier method

MOE_comp <- VRE_combined %>% 
  select(ID, EST_nonmin, EST_tot, MOE_nonmin, MOE_tot, VRE_min_pct, VRE_min_pct_moe, VRE_combined_moe_pct) %>% 
  left_join(TAZ_results_summ, by = "ID")

ggplot(MOE_comp, aes(x=VRE_min_pct_moe, y = min_pct_moe, size = EST_tot)) + geom_point() + coord_equal() + geom_abline(slope = 1)

# Finding where there are the biggest differences
outliers <- MOE_comp %>% 
  mutate(diff = abs(VRE_min_pct_moe - min_pct_moe)) %>% 
  arrange(x = desc(diff)) %>% 
  top_n(22)

avg_pop_outliers <- mean(outliers$TAZ_tot)

ggplot(outliers, aes(x=VRE_min_pct_moe, y = min_pct_moe, size = EST_tot)) + geom_point() + coord_equal() + geom_abline(slope = 1)

# Map

delta_map <- TAZ %>% 
  inner_join(outliers, by = "ID")

mapview(delta_map, zcol = "diff")
```

### Testing Areal-weighted Interpolation of Polygon Data

```{r}

# tracts$GEOID <- as.numeric(tracts$GEOID)
# 
# tracts_w_min <- tracts %>% left_join(minority_tidy)
# 
# tracts_land <- tigris::erase_water(tracts_w_min, 
#                                 area_threshold = 0, 
#                                 year = 2020)
# 
# TAZ_land <- tigris::erase_water(TAZ, 
#                                 area_threshold = 0, 
#                                 year = 2020)
# 
# new_method <- st_interpolate_aw(tracts_land, TAZ_land, extensive = TRUE)
# 
# mapview(new_method, zcol = "min_pop") 
# mapview(TAZ_map, zcol = "LA_min")
```

### Testing

Check that we have retained all of our GEOID area. These values should add up to 100% or 1.0. The areas that do not are very small and may be solved when the script is scaled to include a larger area instead of a single county.

```{r}

flags <- allocation_results |> 
  filter(ID %in% TAZ$ID) |>
  group_by(GEOID) |> 
  summarize(tot_LA_in_tract = sum(TRACT_LA_pct, na.rm = TRUE)) |>
  ungroup() |> 
  filter(tot_LA_in_tract < 0.999 )

mapview(tracts |> filter(GEOID %in% flags$GEOID)) +
  mapview(TAZ |> st_union(), col.regions = "green") 

```

### Compare Population Estimates

```{r}
#| warning: false
#| message: false
library(GGally)

min_results <- TAZ_results %>% 
  select(LA_min)

tot_results <- TAZ_results %>% 
  select(LA_tot)

percentages_ID <- TAZ_results %>% 
  mutate(LA_pct_min = 100 * LA_min / LA_tot) %>% 
  select(ID, LA_pct_min)

percentages <- percentages_ID %>% 
  select(-ID)



```

## Map Comparison

```{r}

# TAZ results
TAZ_map <- TAZ %>% 
  left_join(min_comp) 


# census data
tract_map <- tracts %>% 
  mutate(GEOID = as.numeric(GEOID)) %>% 
  left_join(minority_acs_tract) %>% 
  mutate(pct_min = 1 -  nonmin_pop / tot_pop)


BG_map <- BG %>% 
  mutate(GEOID = as.numeric(GEOID)) %>% 
  left_join(minority_acs_BG) %>% 
  mutate(pct_min = 1 -  nonmin_pop / tot_pop)


# Minority Percent
TAZ_tract <- mapview(TAZ_map, zcol = "tract", at = seq(0,1, .2), lwd = 0, legend = TRUE)
TAZ_BG <- mapview(TAZ_map, zcol = "BG", at = seq(0,1, .2), lwd = 0, legend = TRUE)

mpct_tract <- mapview(tract_map, zcol = "pct_min", at = seq(0,1,0.2),lwd = 0, legend = FALSE)
mpct_BG<- mapview(BG_map, zcol = "pct_min", at = seq(0,1,0.2),lwd = 0, legend = FALSE)



sync(TAZ_tract, TAZ_BG, mpct_tract, mpct_BG) # 4 panels synchronised

```

## Trailing Thoughts

### Thoughts:

Some TAZs are smaller than census block groups. Do we need to adjust the method of analysis for those cases? It could be the same. Since we are looking for the percentage of the block group that is within the TAZ, then it wouldn't matter if it is smaller or larger. In this case, it just wouldn't also be sharing area with other block groups.

![](images/image-779890944.png)

Path forward: use block groups and tracts. ==

Aggregate by share of estimate and share of MOE: 1) use allocation to calculate new fields: estimate_share, moe_share, estimate_min_share, estimate_max_share 2) use combinations of moe_sum and moe_prop from tidycensus to get to percent of taz in category X. 3) perform basic sums for the "estimate_min,max" version 4) repeat for tracts, blk grps 5) Join data to TAZs 6) Compare the four methods.

Do for income and for min_status.
