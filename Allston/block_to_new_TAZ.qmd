---
title: "Rerunning Analysis with New TAZ"
author: "Sophie Fox"
date: "`r Sys.Date()`"
format: 
  html: 
    self-contained: true
editor: visual
---

## General Goal

For TDM 23, a new TAZ was created by splitting one into two sections. This script will run the census to TAZ allocation for the old set of TAZs and the new set of TAZs. The results should be almost identical, as only one TAZ is changing.

There will also be a comparison to the old allocation to our method. These results might be slightly different, since two different methods are involved.

### Useful references

-   massgis census: <https://www.mass.gov/info-details/massgis-data-2020-us-census>

## Set up Packages

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(tidycensus)
library(tigris)
library(mapview)
library(sf)
library(units)
library(rgeos)
library(sp)
library(mapview)
library(leafsync)
library(ggplot2)
library(dplyr)
```

## Load Census and TAZ

```{r}
#| results: hide
 
source("Functions/Census_to_TAZ_functions.R")


#Load TAZ shapes
# MA, RI, and some of NH
# TAZ_new contains the new split TAZ. TAZ_original has the old TAZs
# The file also is already filtered to the MA, RI, and NH area
TAZ_original <- sf::read_sf("J:/Shared drives/TMD_TSA/Releases/TDM23/tdm23.1.0/tdm23/inputs/zonal/shp/CTPS_TDM23_TAZ_2017g_V202303.shp") %>% 
  st_transform(26986)

TAZ_new <- sf::read_sf("J:/Shared drives/TMD_TSA/Projects/MassDOT OnCall/Allston TDM23/scratch/for_Sophie/edited_shape/Final/edited_shape_final.shp") %>% 
  st_transform(26986)

# getting blocks for MA, RI, and part of NH
blocks <- sf::read_sf("J:/Shared drives/TMD_TSA/Data/GIS Data/census_blk/CENSUS2010BLOCKS_POLY.shp") 

# get area of TAZ in m^2
TAZ_original$TAZ_area <- st_area(TAZ_original)
TAZ_new$TAZ_area <- st_area(TAZ_new)


# Need to get the TAZs and blocks of interest. That means every block that intersects with TAZs 6200 and 246, and every TAZ that intersects with those blocks
blocks_of_interest <- blocks[TAZ_original %>% filter(taz_id %in% c(246, 6200)), ]

TAZ_of_interest_original <- TAZ_original[blocks_of_interest,]
TAZ_of_interest_new <- TAZ_new[blocks_of_interest,]

mapview(TAZ_of_interest_original, col.regions = "red") + TAZ_of_interest_new




#mapview(blocks)
```

## Calculate Intersecting Areas

### Find Area of Census Tracts

We find the area of the census tracts. This area will not necessarily match areas reported by the census because of how the coastline is handled and how inland water is handled.

```{r}
blocks_of_interest$BLOCK_TOTAL_AREA <- (st_area(blocks_of_interest))

```

### Intersect Census Tracts with TAZ

```{r}

# Intersection_func function
intersections_block_orig <- intersection_func(TAZ_of_interest_original, geog = blocks_of_interest)
intersections_block_new <- intersection_func(TAZ_of_interest_new, geog = blocks_of_interest)



# Showing the difference in intersections between original and new
mapview(intersections_block_orig, col.regions = "red") + mapview(intersections_block_new, col.regions = "yellow") + mapview(blocks_of_interest, col.regions = "green") + TAZ_of_interest_original + TAZ_of_interest_new + mapview(blocks %>%  filter(GEOID10 == 250173421021085), col.regions = "pink")


# saveRDS(intersections_tract, "data/processed/intersect_tract.rds")

#intersections_tract <- readRDS("data/processed/intersect_tract.rds")

```

We now have the full area of the tracts and the area of the intersections.

### Erase Water From Intersections

We can now remove the water from the intersections. By doing this now, we only remove the water area once. We eliminate the top 80% of the water area.

```{r}
water <-
  area_water(
    state = "MA",
    year = 2020,
    county = fips_codes |> 
      filter(state == "MA") |> 
      select(county_code) |> pull()
  ) |> st_drop_geometry()

# Sort our water find the share of the area and the percentile of each body of water.
water <- water |> 
  arrange(desc(AWATER)) |> 
  mutate(share_of_area = cumsum(AWATER)/sum(AWATER),
         ntile = row_number()/n())

ggplot(water, aes(x= ntile, y = share_of_area)) + 
  geom_point() +
  scale_x_continuous(labels = scales::percent_format()) +
  scale_y_continuous(labels = scales::percent_format()) +
  coord_cartesian(xlim = c(0,0.25))
```

```{r}

# Erasing water

# intersections_block_land_orig <- tigris::erase_water(intersections_block_orig,
#                                 area_threshold = 0.8,
#                                 year = 2020)

intersections_block_land_orig <- intersections_block_orig

intersections_block_land_new <- tigris::erase_water(intersections_block_new,
                                area_threshold = 0.8,
                                year = 2020)

mapview(intersections_block_land_orig, col.regions = "red") + intersections_block_land_new
```

### Recalculate Land Area for the Intersections

We can now recalculate the area to obtain the land area by intersection.

```{r}

intersections_block_land_orig$INTERSECTION_LAND_AREA <- st_area(intersections_block_land_orig)

intersections_block_land_new$INTERSECTION_LAND_AREA <- st_area(intersections_block_land_new)

```

### Find Total Land Area for Blocks

```{r}

intersections_block_land_orig <- intersections_block_land_orig %>% 
  group_by(GEOID10) %>% #grouping by block
  mutate(BLOCK_LAND_AREA = sum(INTERSECTION_LAND_AREA))

intersections_block_land_new <- intersections_block_land_new %>% 
  group_by(GEOID10) %>% #grouping by block
  mutate(BLOCK_LAND_AREA = sum(INTERSECTION_LAND_AREA))

```

For each intersection area we now have the full area of the block and the land area of the block.

### Rejoin to initial intersection dataset

Bring the full dataset back together. We need to join back to the original intersection to maintain all of the "full area". Some of the areas disappear after water is removed. Without these the areas are not fully accounted for.

```{r}

intersections_for_alloc_block_orig <- intersections_block_orig |>
  st_drop_geometry() |>
  select(Intersection_ID, taz_id, GEOID10, 
         INTERSECTION_TOTAL_AREA, BLOCK_TOTAL_AREA) |>
  left_join(
    intersections_block_land_orig |> 
      st_drop_geometry() |> 
      select(Intersection_ID, taz_id, GEOID10, 
             INTERSECTION_LAND_AREA, BLOCK_LAND_AREA),
    by = c("Intersection_ID", "taz_id", "GEOID10")) 


intersections_for_alloc_block_new <- intersections_block_new |>
  st_drop_geometry() |>
  select(Intersection_ID, taz_id, GEOID10, 
         INTERSECTION_TOTAL_AREA, BLOCK_TOTAL_AREA) |>
  left_join(
    intersections_block_land_new |> 
      st_drop_geometry() |> 
      select(Intersection_ID, taz_id, GEOID10, 
             INTERSECTION_LAND_AREA, BLOCK_LAND_AREA),
    by = c("Intersection_ID", "taz_id", "GEOID10")) 




# Note: there are instances where the intersection total area is less than than the intersection land area

```

## Allocate Blocks to TAZs

### Allocate based on Land Area

This calculated the relationship between blocks and TAZs based on land area (LA).

```{r}

area_allocation_block_orig <- intersections_for_alloc_block_orig |> 
  group_by(GEOID10) |> 
    mutate(BLOCK_LA_pct = 
             drop_units(INTERSECTION_LAND_AREA / BLOCK_LAND_AREA)) |> 
  select(Intersection_ID, taz_id, GEOID10, 
         BLOCK_LA_pct) |> 
  group_by(GEOID10, taz_id) |> 
  # summing if the same tract/TAZ pair comes up multiple times
  summarize(BLOCK_LA_pct = sum(BLOCK_LA_pct, na.rm = TRUE)) # |> 
  #filter(ID %in% TAZ_of_interest_original$ID)


area_allocation_block_new <- intersections_for_alloc_block_new |> 
  group_by(GEOID10) |> 
    mutate(BLOCK_LA_pct = 
             drop_units(INTERSECTION_LAND_AREA / BLOCK_LAND_AREA)) |> 
  select(Intersection_ID, taz_id, GEOID10, 
         BLOCK_LA_pct) |> 
  group_by(GEOID10, taz_id) |> 
  # summing if the same tract/TAZ pair comes up multiple times
  summarize(BLOCK_LA_pct = sum(BLOCK_LA_pct, na.rm = TRUE)) # |> 
  #filter(ID %in% TAZ_of_interest_original$ID)


# filter to only look at the TAZ's that were changed

final_orig <- area_allocation_block_orig %>% 
  filter(taz_id %in% c(246, 6200))

final_new <- area_allocation_block_new %>% 
  filter(taz_id %in% c(246, 6200)) %>% 
  rename(block_id = GEOID10, area_fct = BLOCK_LA_pct)

# Compare the original allocations 
base_allocations <- read_csv("J:/Shared drives/TMD_TSA/Releases/TDM23/tdm23.1.0/tdm23/inputs/zonal/shp/taz_2010block_allocation_20230314.csv", col_types = "ccn") %>% 
  mutate(taz_id = as.numeric(taz_id)) #%>% 
  # filter(taz_id == 246)
  # filter(block_id %in% final_orig$GEOID10)


TAZ_changed <- TAZ_of_interest_new %>% filter(taz_id %in% c(6200, 246))

 mapview(intersections_block_new, col.regions = "green") +
  mapview(TAZ_changed, col.regions = "blue")

 blocks_to_remove <- final_new$block_id[final_new$taz_id == 6200 & final_new$area_fct < 0.01]

 blocks_to_remove <- c(blocks_to_remove, 250250008021001, 250250008021000)
 # 7 blocks to remove from the new tazs (6 in 6200, 1 in 246)
    
mapview(intersections_block_new %>% filter(GEOID10 %in% blocks_to_remove &
                                             taz_id %in% c(6200, 246)), col.regions = "orange") + mapview(TAZ_changed)

final_new_trimmed <- final_new %>% filter(!(block_id %in% blocks_to_remove)) %>% 
  mutate(block_id = as.character(block_id))


```

#### Replace Base Allocations with New Ones for TAZs of interest

```{r}


final_results <- base_allocations %>% 
  filter(taz_id != 246) %>% 
  bind_rows(final_new_trimmed) 


# The original "base" allocation work had 38 blocks intersecting with TAZ 246. With our method, the unsplit TAZ has 45 intersections. With the split, there were 34 blocks intersecting with TAZ 246, and 24 split with TAZ 6200. The 58 allocations are replacing the 38 in the original "base" work. 
```

#### Check Results

We want to verify that we have maintained area. We want 100% of the area accounted for. This may be not as true now that we've included extra buffer area. We may want 100% of the area included for the TAZs inside the MPO boundary.

```{r}

#blocks_in_new_tazs <- final_results$block_id[final_results$taz_id %in% c(246, 6200)]

final_results_summed <- final_results %>% 
  #filter(block_id %in% blocks_in_new_tazs) %>% 
  group_by(block_id) %>% 
  summarise(summed_pct_new = sum(area_fct))

# compare to base
base_allocations_summed <- base_allocations %>% 
  #filter(block_id %in% blocks_in_new_tazs) %>% 
  group_by(block_id) %>% 
  summarise(summed_pct_base = sum(area_fct))

# Comparison
comp_sum <- full_join(final_results_summed, base_allocations_summed) %>% 
  mutate(same = summed_pct_base == summed_pct_new) %>% 
  filter(same == FALSE) %>% 
  mutate(diff = summed_pct_new - summed_pct_base)

unequal_blocks <- blocks %>% filter(GEOID10 %in% comp_sum$block_id)
mapview(unequal_blocks, col.regions = "red") + mapview(TAZ_changed)
```

There are three land_area values that are equal to `0`, rather than `1`. They are in the water.

\###################################################################

## New Method- Manual Sorting

```{r}

base_allocations <- read_csv("J:/Shared drives/TMD_TSA/Releases/TDM23/tdm23.1.0/tdm23/inputs/zonal/shp/taz_2010block_allocation_20230314.csv", col_types = "ccn") %>% 
  mutate(taz_id = as.numeric(taz_id))
  
Allston_TAZs <- sf::read_sf("J:/Shared drives/TMD_TSA/Projects/MassDOT OnCall/Allston TDM23/scratch/for_Sophie/edited_shape/Final/edited_shape_final.shp") %>% 
  st_transform(26986)%>% 
  filter(taz_id %in% c(246, 6200))

blocks <- sf::read_sf("J:/Shared drives/TMD_TSA/Data/GIS Data/census_blk/CENSUS2010BLOCKS_POLY.shp") 

# blocks in the base allocations that intersect with taz 246
base_blocks_filtered <-  base_allocations %>% 
  filter(taz_id %in% c(246, 6200))
# 38 blocks

# blocks of those 38 that do not include the water blocks, since those are not in the original blocks dataset
base_allocations_filtered <- blocks %>% 
  filter(GEOID10 %in% base_blocks_filtered$block_id)
# 35 blocks

# mapping the three missing blocks. They are in the water
# missing <- tigris::blocks(state = 25, county = 25, year = 2010) |> filter(GEOID10 %in% c(250259815011056, 250259815011036,250259815011035)) |> mapview::mapview(zcol = "GEOID10") 

# blocks that overlap with the two Allson TAZs
blocks_to_sort_overlap <- blocks[Allston_TAZs,]
# 45 blocks

mapview(blocks_to_sort_overlap, col.regions = "orange") + mapview(base_allocations_filtered, col.regions = "purple") + mapview(Allston_TAZs)
# There are ten blocks (orange), that barely overlap with the TAZs, but aren't included in the original allocations as intersecting with 246. So we will be leavin g those alone. 

# Using base_allocations_filtered
mapview(base_allocations_filtered, col.regions = "green") + mapview(Allston_TAZs , zcol = "taz_id")

taz_6200_blocks <- c(250250008031040, 250250008031031, 250250008031032, 250250008031034, 250250008031018, 250250008032004, 250250008032003, 250250008032012, 250250008032011 )

new_6200 <- base_allocations_filtered %>% filter(GEOID10 %in% taz_6200_blocks)

new_246 <- base_allocations_filtered %>% filter(!(GEOID10 %in% taz_6200_blocks))

mapview(new_6200, col.regions = "red") + mapview(new_246, col.regions = "orange") + mapview(Allston_TAZs)


new_allocations <- base_allocations %>% 
  mutate(taz_id = if_else(taz_id == 246 & block_id %in% taz_6200_blocks,
                          6200,
                          taz_id)
         )

write_csv(new_allocations, "C:/Users/sfox.AD/Documents/GitHub/block_to_TAZ_vehicles/Allston/Output/taz_2010block_allocation_newsplit_20240517.csv")


```
